/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <fcntl.h>
#include <regex.h>
#include "log.h"
#include "ram.h"
#include "util.h"
#include "command.h"
#include "main.h"

struct ram_cache_s
{
  uint32_t wired;
  uint32_t active;
  uint32_t inactive;
  uint32_t used;
  uint32_t free;
};

#define MAX_CACHE_AGE 10

static struct ram_cache_s ram_cache;
static struct timeval ram_cache_timestamp;

static uint32_t match_and_scale(const char *start, regmatch_t group)
{
  char *val_str, *end = NULL;
  asprintf(&val_str, "%.*s", (int)(group.rm_eo -  group.rm_so), start + group.rm_so);
  uint32_t val = strtoul(val_str, &end, 10);
  scale_value_to_m(end[0], &val);
  free(val_str);
  return val;
}

void update_ram()
{
  char *data = NULL;
  size_t data_len = 0;
  if (xsan_debug())
  {
    /* Use example data */
    int fd;
    fd = open ("../examples/top.txt", O_RDONLY);
    data = malloc (65536);
    data_len =  read (fd, data, 65535);
    data[data_len] = '\0';
    close (fd);
  }
  else
  {
    /* Use live data */
    data = x_command_run("top -l 1 -n 0");
    data_len = strlen(data);
  }

  /* Match and scale data */
  if (!data) return;
  
  regex_t re;
  int rc = regcomp(&re, "^PhysMem: ([0-9]+[KMGT]) wired" /*  1 wired */
                   ", ([0-9]+[KMGT]) active" /*  2 active */
                   ", ([0-9]+[KMGT]) inactive" /*  3 inactive */
                   ", ([0-9]+[KMGT]) used" /*  4 used */
                   ", ([0-9]+[KMGT]) free\\.$" /*  5 free */
                   , REG_EXTENDED | REG_NEWLINE);
  
  if (rc) {
    x_printf("ERROR: update_ram failed to compile regex");
    free(data);
    return;
  }
  
  const size_t ocount = 30;
  regmatch_t ovector[ocount];
  
  memset(ovector, 0, sizeof(ovector));
  rc = regexec(&re, data, ocount, ovector, 0);
  regfree(&re);
  
  if (rc == 0) {
    ram_cache.wired = match_and_scale(data, ovector[1]);
    ram_cache.active = match_and_scale(data, ovector[2]);
    ram_cache.inactive = match_and_scale(data, ovector[3]);
    ram_cache.used = match_and_scale(data, ovector[4]);
    ram_cache.free = match_and_scale(data, ovector[5]);
  } else {
    x_printf("ERROR: update_ram got no match");
  }
  
  /* Set cache timestamp */
  gettimeofday(&ram_cache_timestamp, NULL);  

  /* Cleanup */
  free (data);
  data = NULL;
  data_len = 0;
}

void update_ram_if_necessary ()
{
  struct timeval now;
  gettimeofday(&now, NULL);
  if ((now.tv_sec - ram_cache_timestamp.tv_sec) > MAX_CACHE_AGE)
  {
    update_ram();
  }
}

/** Initializes the ram module */
void
init_ram(void)
{
    static oid ramWired_oid[] = { 1,3,6,1,4,1,20038,2,1,3,1 };
    static oid ramActive_oid[] = { 1,3,6,1,4,1,20038,2,1,3,2 };
    static oid ramInactive_oid[] = { 1,3,6,1,4,1,20038,2,1,3,3 };
    static oid ramUsed_oid[] = { 1,3,6,1,4,1,20038,2,1,3,4 };
    static oid ramFree_oid[] = { 1,3,6,1,4,1,20038,2,1,3,5 };

  DEBUGMSGTL(("ram", "Initializing\n"));
  
  memset (&ram_cache, 0, sizeof(struct ram_cache_s));
  memset (&ram_cache_timestamp, 0, sizeof(struct timeval));
  

    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ramWired", handle_ram,
                               ramWired_oid, OID_LENGTH(ramWired_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ramActive", handle_ram,
                               ramActive_oid, OID_LENGTH(ramActive_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ramInactive", handle_ram,
                               ramInactive_oid, OID_LENGTH(ramInactive_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ramUsed", handle_ram,
                               ramUsed_oid, OID_LENGTH(ramUsed_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("ramFree", handle_ram,
                               ramFree_oid, OID_LENGTH(ramFree_oid),
                               HANDLER_CAN_RONLY
        ));
}

int
handle_ram (netsnmp_mib_handler *handler, 
            netsnmp_handler_registration *reginfo,
            netsnmp_agent_request_info   *reqinfo,
            netsnmp_request_info         *requests)
{
  uint32_t val = 0;
  switch(reqinfo->mode) 
  {
    case MODE_GET:
      update_ram_if_necessary();
      if (!strcmp(reginfo->handlerName, "ramWired")) val = ram_cache.wired;
      if (!strcmp(reginfo->handlerName, "ramActive")) val = ram_cache.active;
      if (!strcmp(reginfo->handlerName, "ramInactive")) val = ram_cache.inactive;
      if (!strcmp(reginfo->handlerName, "ramUsed")) val = ram_cache.used;
      if (!strcmp(reginfo->handlerName, "ramFree")) val = ram_cache.free;
      snmp_set_var_typed_value(requests->requestvb, ASN_GAUGE, (u_char *)&val, sizeof(uint32_t));
      break;
    default:
      /* we should never get here, so this is a really bad error */
      snmp_log(LOG_ERR, "unknown mode (%d) in handle_ram\n", reqinfo->mode );
      return SNMP_ERR_GENERR;
  }

  return SNMP_ERR_NOERROR;
}

void test_ram()
{
  update_ram();
  
  // dump result
  printf("wired=%u\n", ram_cache.wired);
  printf("active=%u\n", ram_cache.active);
  printf("inactive=%u\n", ram_cache.inactive);
  printf("used=%u\n", ram_cache.used);
  printf("free=%u\n", ram_cache.free);
}
