/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 15999 2007-03-25 22:32:02Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "xsanNodeTable.h"
#include <pcre.h>
#include <fcntl.h>
#include "log.h"
#include "util.h"
#include "command.h"
#include "main.h"

#define OVECCOUNT 90

static int node_list_detail_invalid = 1;
static struct timeval nodelist_cache_timestamp = {0, 0};

void update_node_list ();
void update_node_list_detail();

#define MAX_CACHE_AGE 10

/** Initializes the xsanNodeTable module */
void
init_xsanNodeTable(void)
{
  initialize_table_xsanNodeTable();
}

/** Initialize the xsanNodeTable table by defining its contents and how it's structured */
void
initialize_table_xsanNodeTable(void)
{
  static oid xsanNodeTable_oid[] = {1,3,6,1,4,1,20038,2,1,1,3};
  size_t xsanNodeTable_oid_len   = OID_LENGTH(xsanNodeTable_oid);
  netsnmp_handler_registration    *reg;
  netsnmp_iterator_info           *iinfo;
  netsnmp_table_registration_info *table_info;

  reg = netsnmp_create_handler_registration(
            "xsanNodeTable",     xsanNodeTable_handler,
            xsanNodeTable_oid, xsanNodeTable_oid_len,
            HANDLER_CAN_RONLY
            );

  table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
  netsnmp_table_helper_add_indexes(table_info,
                         ASN_INTEGER,  /* index: xsanVolumeIndex */
                         ASN_INTEGER,  /* index: xsanStripeGroupIndex */
                         ASN_INTEGER,  /* index: xsanNodeIndex */
                         0);
  table_info->min_column = COLUMN_XSANNODEINDEX;
  table_info->max_column = COLUMN_XSANNODESIZE;
  
  iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
  iinfo->get_first_data_point = xsanNodeTable_get_first_data_point;
  iinfo->get_next_data_point  = xsanNodeTable_get_next_data_point;
  iinfo->table_reginfo        = table_info;
  
  netsnmp_register_table_iterator( reg, iinfo );
  
  update_node_list();
  update_node_list_detail();
}

/* Typical data structure for a row entry */
struct xsanNodeTable_entry 
{
  /* Index values */
  long xsanVolumeIndex;
  long xsanStripeGroupIndex;
  long xsanNodeIndex;

  /* Column values */
  char *xsanNodeName;
  size_t xsanNodeName_len;
  char *xsanNodeController;
  size_t xsanNodeController_len;
  char *xsanNodeSerial;
  size_t xsanNodeSerial_len;
  char *xsanNodeGUID;
  size_t xsanNodeGUID_len;
  char *xsanNodeDevice;
  size_t xsanNodeDevice_len;
  char *xsanNodeDeviceLabel;
  size_t xsanNodeDeviceLabel_len;
  char *xsanNodeFSType;
  size_t xsanNodeFSType_len;
  u_long xsanNodeSectorSize;
  U64 xsanNodeSectors;
  U64 xsanNodeMaxSectors;
  u_long xsanNodeKSectors;
  u_long xsanNodeMaxKSectors;
  long xsanNodeVisible;
  u_long xsanNodeSize;
  
  /* Obsolescence */
  time_t last_seen_in_stripe_group;
  time_t last_seen_in_cvlabel;

  /* Illustrate using a simple linked list */
  struct xsanNodeTable_entry *next;
};

struct xsanNodeTable_entry  *xsanNodeTable_head;

/* create a new row in the (unsorted) table */
struct xsanNodeTable_entry *
xsanNodeTable_createEntry(
                 long  xsanVolumeIndex,
                 long  xsanStripeGroupIndex,
                 long  xsanNodeIndex) 
{
  struct xsanNodeTable_entry *entry;

  entry = SNMP_MALLOC_TYPEDEF(struct xsanNodeTable_entry);
  if (!entry) return NULL;

  entry->xsanVolumeIndex = xsanVolumeIndex;
  entry->xsanStripeGroupIndex = xsanStripeGroupIndex;
  entry->xsanNodeIndex = xsanNodeIndex;
  entry->next = xsanNodeTable_head;
  xsanNodeTable_head = entry;
  node_list_detail_invalid = 1;
  return entry;
}

/* remove a row from the table */
void
xsanNodeTable_removeEntry( struct xsanNodeTable_entry *entry ) 
{
  struct xsanNodeTable_entry *ptr, *prev;

  if (!entry)
      return;    /* Nothing to remove */

  for ( ptr  = xsanNodeTable_head, prev = NULL;
        ptr != NULL;
        prev = ptr, ptr = ptr->next ) {
      if ( ptr == entry )
          break;
  }
  if ( !ptr )
      return;    /* Can't find it */

  if ( prev == NULL )
      xsanNodeTable_head = ptr->next;
  else
    prev->next = ptr->next;

  if (entry->xsanNodeName) free(entry->xsanNodeName);

  SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
xsanNodeTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
  *my_loop_context = xsanNodeTable_head;
  return xsanNodeTable_get_next_data_point(my_loop_context, my_data_context,
                                  put_index_data,  mydata );
}

netsnmp_variable_list *
xsanNodeTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
  struct xsanNodeTable_entry *entry = (struct xsanNodeTable_entry *)*my_loop_context;
  netsnmp_variable_list *idx = put_index_data;

  if ( entry ) 
  {
    snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->xsanVolumeIndex );
    idx = idx->next_variable;
    snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->xsanStripeGroupIndex );
    idx = idx->next_variable;
    snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->xsanNodeIndex );
    idx = idx->next_variable;
    *my_data_context = (void *)entry;
    *my_loop_context = (void *)entry->next;
    return put_index_data;
  } 
  else 
  {
    return NULL;
  }
}

void update_nodes_for_stripe_group(char *data, size_t data_len, long volumeIndex, long stripeGroupIndex)
{
  /* Updates the node list from the output of a 'show long' */
    struct timeval now;
    gettimeofday (&now, NULL);

    const char *error;
    int erroffset;
    int ovector[OVECCOUNT];
    pcre *re = pcre_compile("^[ ]*Node (\\d+) \\[(.*)\\]", PCRE_MULTILINE, &error, &erroffset, NULL);

    if (re == NULL) { x_printf ("ERROR: update_nodes_for_stripe_group failed to compile regex"); return; }

    ovector[0] = 0;
    ovector[1] = 0;
    while(1)
    {
        int options = 0;                 /* Normally no options */
        int start_offset = ovector[1];   /* Start at end of previous match */

        if (ovector[0] == ovector[1])
        {
            if (ovector[0] == (int)data_len) break;
        }

        int rc = pcre_exec(
                            re,                   /* the compiled pattern */
                            NULL,                 /* no extra data - we didn't study the pattern */
                            data,              /* the subject string */
                            data_len,       /* the length of the subject */
                            start_offset,         /* starting offset in the subject */
                            options,              /* options */
                            ovector,              /* output vector for substring information */
                            OVECCOUNT);           /* number of elements in the output vector */

        if (rc == PCRE_ERROR_NOMATCH)
        {
            if (options == 0) break;
            ovector[1] = start_offset + 1;
            continue;    /* Go round the loop again */
        }

        /* Other matching errors are not recoverable. */
        if (rc > 0)
        {
            /* Matched an Xsan Stripe Group. Vectors: 
             *    0 = Full text match for stripe group
             *    1(2) = Node Index (assigned by cvadmin)
             *    2(4) = Node Name
             */
             
            long nodeIndex = extract_uint_in_range (data + ovector[2], ovector[3] - ovector[2]);

            struct xsanNodeTable_entry *entry = xsanNodeTable_head;
            while (entry)
            {
                if (entry->xsanVolumeIndex == volumeIndex && entry->xsanStripeGroupIndex == stripeGroupIndex && entry->xsanNodeIndex == nodeIndex) break;
                entry = entry->next;
            }
            if (!entry)
            {
                entry = xsanNodeTable_createEntry (volumeIndex, stripeGroupIndex, nodeIndex);
            }
            entry->last_seen_in_stripe_group = now.tv_sec;
            
            extract_string_in_range (data + ovector[4], ovector[5] - ovector[4], &entry->xsanNodeName, &entry->xsanNodeName_len);
        }
        else
        {
            pcre_free(re);    /* Release memory used for the compiled pattern */
            return;
        }  
    }    
    
    pcre_free(re);    /* Release memory used for the compiled pattern */
    
    /* Obsolescence Checking */
    struct xsanNodeTable_entry *entry = xsanNodeTable_head;
    while (entry)
    {
        struct xsanNodeTable_entry *next = entry->next;
        if (entry->xsanVolumeIndex == volumeIndex && entry->xsanStripeGroupIndex == stripeGroupIndex && entry->last_seen_in_stripe_group != now.tv_sec)
        {
            /* Entry is obsolete */
            xsanNodeTable_removeEntry(entry);
        }
        entry = next;
    }
    
}

void update_node_list ()
{
  /* Updates the list of visible nodes using the non-invasive 'cvlabel -l' 
   * This data is cached and only updated periodically to ensure a current
   * list of visible disks is presented
   */
   struct timeval now;
   gettimeofday (&now, NULL);

   char *data = NULL;
   size_t data_len = 0;
   if (xsan_debug())
   {
     /* Use example Xsan data */
     int fd;
     fd = open ("../examples/cvlabel_example.txt", O_RDONLY);
     data = malloc (65536);
     data_len =  read (fd, data, 65535);
     data[data_len] = '\0';     
     close (fd);     
   }
   else
   {
     /* Use live Xsan data */
     data = x_command_run("cvlabel -a -g -l -v");
     if (!data) return;
     data_len = strlen(data);     
   }

   const char *error;
   int erroffset;
   int ovector[OVECCOUNT];
   pcre *re = pcre_compile("^(/dev[^ ]+) \\[(.*)\\] ([^ ]+) \\\"([^\\\"]*)\\\"[ ]*Sectors: (\\d+)\\.[ ]*SectorSize: (\\d+)\\.[ ]*Maximum sectors: (\\d+)\\.[ ]*GUID ([^ ]+).*$", PCRE_MULTILINE, &error, &erroffset, NULL);

   if (re == NULL) { x_printf ("ERROR: update_node_list failed to compile regexupdate_node_list"); free (data); return; }

   ovector[0] = 0;
   ovector[1] = 0;
   while(1)
   {
     int options = 0;                 /* Normally no options */
     int start_offset = ovector[1];   /* Start at end of previous match */

     if (ovector[0] == ovector[1])
     {
       if (ovector[0] == (int)data_len) break;
     }

     int rc = pcre_exec( re,                   /* the compiled pattern */
                          NULL,                 /* no extra data - we didn't study the pattern */
                          data,              /* the subject string */
                          data_len,       /* the length of the subject */
                          start_offset,         /* starting offset in the subject */
                          options,              /* options */
                          ovector,              /* output vector for substring information */
                          OVECCOUNT);           /* number of elements in the output vector */

     if (rc == PCRE_ERROR_NOMATCH)
     {
       if (options == 0) break;
       ovector[1] = start_offset + 1;
       continue;    /* Go round the loop again */
     }

     /* Other matching errors are not recoverable. */
     if (rc > 0)
     {
       /* Matched an Xsan Volume. Vectors:
        * 0=FullString 1(2)=Disk 2(4)=DeviceName 3(6)=FSType 4(8)=NodeName
        * 5(10)=Sectors 6(12)=SectorSize 7(14)=MaxSectors
        * 8(16)=GUID
       */
       char *nodename_str;
       asprintf (&nodename_str, "%.*s", ovector[9] - ovector[8], data + ovector[8]);
       trim_end(nodename_str);

       struct xsanNodeTable_entry *entry = xsanNodeTable_head;
       while (entry)
       {
         if (!strcmp(nodename_str, entry->xsanNodeName)) break;
         entry = entry->next;
       }
       if (entry)
       {
         entry->last_seen_in_cvlabel = now.tv_sec;

         extract_string_in_range (data + ovector[2], ovector[3] - ovector[2], &entry->xsanNodeDevice, &entry->xsanNodeDevice_len);
         extract_string_in_range (data + ovector[4], ovector[5] - ovector[4], &entry->xsanNodeDeviceLabel, &entry->xsanNodeDeviceLabel_len);
         extract_string_in_range (data + ovector[6], ovector[7] - ovector[6], &entry->xsanNodeFSType, &entry->xsanNodeFSType_len);
         extract_string_in_range (data + ovector[16], ovector[17] - ovector[16], &entry->xsanNodeGUID, &entry->xsanNodeGUID_len);

         entry->xsanNodeSectorSize = extract_uint_in_range (data + ovector[12], ovector[13] - ovector[12]);

         extract_U64_in_range (data + ovector[10], ovector[11] - ovector[10], &entry->xsanNodeSectors);
         extract_U64_in_range (data + ovector[14], ovector[15] - ovector[14], &entry->xsanNodeMaxSectors);
       
         entry->xsanNodeKSectors = scale_U64_to_K(&entry->xsanNodeSectors);
         entry->xsanNodeMaxKSectors = scale_U64_to_K(&entry->xsanNodeMaxSectors);
         
         entry->xsanNodeSize = (entry->xsanNodeKSectors / 1000) * entry->xsanNodeSectorSize;
       }
       
       free (nodename_str);
       nodename_str = NULL;
     }
     else
     {
       pcre_free(re);    /* Release memory used for the compiled pattern */
       return;
     }  
     
     
   }

   pcre_free(re);    /* Release memory used for the compiled pattern */

   /* Check for non-visible (obsolete) entries */
   struct xsanNodeTable_entry *entry = xsanNodeTable_head;
   while (entry)
   {
     if (entry->last_seen_in_cvlabel == now.tv_sec)
     {
       /* Entry is visible */
       entry->xsanNodeVisible = 1;
     }
     else
     {
       /* Entry is obsolete, mark it as not visible */
       entry->xsanNodeVisible = 0;
     }
     entry = entry->next;
   }

   /* Update cache timestamp */
   gettimeofday(&nodelist_cache_timestamp, NULL);

   /* Clean up */
   free (data);
   data = NULL;
   data_len = 0;
}

void update_node_list_if_necessary()
{
  struct timeval now;
  gettimeofday (&now, NULL);
  if (now.tv_sec - nodelist_cache_timestamp.tv_sec > MAX_CACHE_AGE) update_node_list();
}

void update_node_list_detail()
{
  /* Updates the list of visible nodes using the invasive 'cvlabel -L' 
   * This is only done if the cache of detailed data is invalidated due 
   * to a new node being discovered
   */

   struct timeval now;
   gettimeofday (&now, NULL);

   char *data = NULL;
   size_t data_len = 0;
   if (xsan_debug())
   {
     /* Use example Xsan data */
     int fd;
     fd = open ("../examples/cvlabel_detail_example.txt", O_RDONLY);
     data = malloc (65536);
     data_len =  read (fd, data, 65535);
     data[data_len] = '\0';
     close (fd);
   }
   else
   {
     /* Use live Xsan data */
     data = x_command_run("cvlabel -a -g -L -v");
     if (!data) return;
     data_len = strlen(data);
   }

   const char *error;
   int erroffset;
   int ovector[OVECCOUNT];
   pcre *re = pcre_compile("^/dev[^ ]+ \\[.*\\] [^ ]+ \\\"([^\\\"]*)\\\"[ ]*Controller \\'([^\\']+)\\',[ ]*Serial \\'([^\\']+)\\',.*$", PCRE_MULTILINE, &error, &erroffset, NULL);

   if (re == NULL) { x_printf ("ERROR: update_node_list_detail failed to compile regex"); free (data); return; }

   ovector[0] = 0;
   ovector[1] = 0;
   while(1)
   {
     int options = 0;                 /* Normally no options */
     int start_offset = ovector[1];   /* Start at end of previous match */

     if (ovector[0] == ovector[1])
     {
       if (ovector[0] == (int)data_len) break;
     }

     int rc = pcre_exec( re,                   /* the compiled pattern */
                          NULL,                 /* no extra data - we didn't study the pattern */
                          data,              /* the subject string */
                          data_len,       /* the length of the subject */
                          start_offset,         /* starting offset in the subject */
                          options,              /* options */
                          ovector,              /* output vector for substring information */
                          OVECCOUNT);           /* number of elements in the output vector */

     if (rc == PCRE_ERROR_NOMATCH)
     {
       if (options == 0) break;
       ovector[1] = start_offset + 1;
       continue;    /* Go round the loop again */
     }

     /* Other matching errors are not recoverable. */
     if (rc > 0)
     {
       /* Matched an Xsan Volume. Vectors:
        * 0=FullString 1(2)=NodeName 2(4)=Controller 3(6)=Serial
       */
       char *nodename_str;
       asprintf (&nodename_str, "%.*s", ovector[3] - ovector[2], data + ovector[2]);
       trim_end(nodename_str);

       struct xsanNodeTable_entry *entry = xsanNodeTable_head;
       while (entry)
       {
         if (!strcmp(nodename_str, entry->xsanNodeName)) break;
         entry = entry->next;
       }
       if (entry)
       {
         extract_string_in_range (data + ovector[4], ovector[5] - ovector[4], &entry->xsanNodeController, &entry->xsanNodeController_len);
         extract_string_in_range (data + ovector[6], ovector[7] - ovector[6], &entry->xsanNodeSerial, &entry->xsanNodeSerial_len);
       }
       
       free (nodename_str);
       nodename_str = NULL;
     }
     else
     {
       pcre_free(re);    /* Release memory used for the compiled pattern */
       return;
     }  
   }

   pcre_free(re);    /* Release memory used for the compiled pattern */

   /* Clean up */
   free (data);
   data = NULL;
   data_len = 0;

   /* Set validity */
   node_list_detail_invalid = 0;
}

void update_node_list_detail_if_necessary()
{
  if (node_list_detail_invalid) update_node_list_detail();
}



/** handles requests for the xsanNodeTable table */
int
xsanNodeTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct xsanNodeTable_entry          *table_entry;

    update_node_list_if_necessary();
    update_node_list_detail_if_necessary();

    switch (reqinfo->mode) {
      /*
       * Read-support (also covers GetNext requests)
       */
      case MODE_GET:
          for (request=requests; request; request=request->next) 
          {
            table_entry = (struct xsanNodeTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_XSANVOLUMEINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->xsanVolumeIndex);
                break;
            case COLUMN_XSANNODENAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeName,
                                          table_entry->xsanNodeName_len);
                break;
            case COLUMN_XSANNODECONTROLLER:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeController,
                                          table_entry->xsanNodeController_len);
                break;
            case COLUMN_XSANNODESERIAL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeSerial,
                                          table_entry->xsanNodeSerial_len);
                break;
            case COLUMN_XSANNODEGUID:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeGUID,
                                          table_entry->xsanNodeGUID_len);
                break;
            case COLUMN_XSANNODEDEVICE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeDevice,
                                          table_entry->xsanNodeDevice_len);
                break;
            case COLUMN_XSANNODEDEVICELABEL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeDeviceLabel,
                                          table_entry->xsanNodeDeviceLabel_len);
                break;
            case COLUMN_XSANNODEFSTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                 (u_char*)table_entry->xsanNodeFSType,
                                          table_entry->xsanNodeFSType_len);
                break;
            case COLUMN_XSANNODESECTORSIZE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_GAUGE,
                                            table_entry->xsanNodeSectorSize);
                break;
            case COLUMN_XSANNODESECTORS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER64,
                                 (u_char*)&table_entry->xsanNodeSectors,
                                          sizeof(U64));
                break;
            case COLUMN_XSANNODEMAXSECTORS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_COUNTER64,
                                 (u_char*)&table_entry->xsanNodeMaxSectors,
                                          sizeof(U64));
                break;
            case COLUMN_XSANNODEKSECTORS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_GAUGE,
                                            table_entry->xsanNodeKSectors);
                break;
            case COLUMN_XSANNODEMAXKSECTORS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_GAUGE,
                                            table_entry->xsanNodeMaxKSectors);
                break;
            case COLUMN_XSANNODEVISIBLE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->xsanNodeVisible);
                break;
            case COLUMN_XSANNODESIZE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_GAUGE,
                                            table_entry->xsanNodeSize);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    }
    return SNMP_ERR_NOERROR;
}
